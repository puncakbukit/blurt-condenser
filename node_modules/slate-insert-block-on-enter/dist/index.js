'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slate = require('slate');

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Debug.
 *
 * @type {Function}
 */

var debug = (0, _debug2.default)('slate:insert-block-on-enter');

/**
 * A Slate plugin to insert a spesific node when enter is hit on a void node.
 *
 * @param {Mixed} ...args
 * @return {Object}
 */

function InsertBlockOnEnterPlugin() {
  var createBlockProps = void 0;
  var blockInputProps = arguments.length <= 0 ? undefined : arguments[0];
  if ((typeof blockInputProps === 'undefined' ? 'undefined' : _typeof(blockInputProps)) !== 'object') {
    throw new Error('Expected first argument to be a hash of block properties.');
  }

  /**
    *
    * @param {Event} e
    * @param {Object} data
    * @param {State} state
    * @return {State}
    */

  function onKeyDown(e, data, state) {
    if (data.key === 'enter') {
      var document = state.document;
      var startKey = state.startKey;
      var startBlock = state.startBlock;


      if (startBlock && startBlock.isVoid) {
        var nextBlock = document.getNextBlock(startKey);
        var prevBlock = document.getPreviousBlock(startKey);
        var isFocusedStart = state.selection.hasEdgeAtStartOf(startBlock);
        var isFocusedEnd = state.selection.hasEdgeAtEndOf(startBlock);
        var blockToInsert = _slate.Raw.deserializeNode(blockInputProps);

        // Void block at the end of the document
        if (!nextBlock) {
          if (isFocusedEnd) {
            debug('no nextBlock, PrevBlock, isFocusedEnd');
            return state.transform().collapseToEndOf(startBlock).insertBlock(blockToInsert).collapseToEnd().apply();
          }
          if (prevBlock) {
            debug('no nextBlock, PrevBlock, isFocusedStart');
            var index = document.nodes.indexOf(prevBlock);
            return state.transform().collapseToEndOf(prevBlock).insertNodeByKey(document.key, index + 1, blockToInsert).collapseToStartOf(startBlock).apply();
          }
          debug('no nextBlock, no PrevBlock');
          return state.transform().collapseToStartOf(startBlock).insertNodeByKey(document.key, 0, blockToInsert).apply();
        }
        // Void block between two blocks
        if (nextBlock && prevBlock) {
          if (isFocusedStart) {
            debug('nextBlock, prevBlock, isFocusedStart');
            var _index = document.nodes.indexOf(prevBlock);
            return state.transform().collapseToEndOf(prevBlock).insertNodeByKey(document.key, _index + 1, blockToInsert).collapseToStartOf(startBlock).apply();
          }
          debug('nextBlock, prevBlock, isFocusedEnd');
          return state.transform().collapseToEndOf(startBlock).insertBlock(blockToInsert).collapseToEnd().apply();
        }
        // Void block in the beginning of the document
        if (nextBlock && !prevBlock) {
          if (isFocusedStart) {
            debug('nextBlock, no prevBlock, isFocusedStart');
            return state.transform().collapseToStartOf(startBlock).insertNodeByKey(document.key, 0, blockToInsert).apply();
          }
          debug('nextBlock, no prevBlock, isFocusedEnd');
          return state.transform().collapseToEndOf(startBlock).insertBlock(blockToInsert).apply();
        }
      }
    }
  }

  /**
   * Return the plugin.
   */

  return {
    onKeyDown: onKeyDown
  };
}

/**
 * Export.
 */

exports.default = InsertBlockOnEnterPlugin;