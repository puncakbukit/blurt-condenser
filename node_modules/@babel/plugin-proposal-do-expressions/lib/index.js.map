{"version":3,"names":["_helperPluginUtils","require","_utils","_default","exports","default","declare","api","_api$assumption","assertVersion","types","t","noDocumentAll","assumption","name","manipulateOptions","_","parser","plugins","push","visitor","DoExpression","exit","path","node","async","controlFlowState","collectControlFlowStatements","returnPath","break","size","continue","transformDoExpressionWithControlFlowStatements","body","length","replaceExpressionWithStatements","replaceWith","scope","buildUndefinedNode","doExprPath","doAncestors","WeakSet","add","isFunction","get","isArrowFunctionExpression","isExpression","has","blockStatement","returnStatement","flattenStatement","foundDoExpression","deferredPatterns","deferredTemps","param","actualParam","isRestElement","isTSParameterProperty","isLValSideEffectFree","pattern","uid","generateUidIdentifier","cloneNode","blockBody","isBlockStatement","unshiftContainer","variableDeclaration","variableDeclarator","arrayPattern","arrayExpression","isStatement","parentPath","Error","type","statements","decl","init","id","flattenExpression","flattenLVal","kind","replaceWithMultiple","test","ifStatement","unaryExpression","breakStatement","remove","update","discardResult","set","initNode","expressionStatement","newPath","left","generateDeclaredUidIdentifier","isVariableDeclaration","buildCodeFrameError","newBody","right","booleanLiteral","insertBefore","flattenByTraverse","opts","isTopLevelCopyable","flattenTrailing","hasDoExpression","isDoExpression","completions","getCompletionRecords","filter","completion","isExpressionStatement","assignmentExpression","expression","isAssignmentExpression","operator","isLogicalExpression","binaryExpression","nullLiteral","logicalExpression","isConditionalExpression","alternate","consequent","conditionalExpression","isOptionalMemberExpression","computed","object","property","buildOptionalChainChecker","memberExpression","isOptionalCallExpression","callee","calleeStatements","callExpression","arguments","callStatements","flattenCallExpression","isCallExpression","intoTempVariable","thisArgument","isMemberExpression","isSuper","arg","isSpreadElement","spreadElement","identifier","thisExpression","wrapDoExpressionInIIFE","elements","element","restElement","expressions","traverse","Statement","skip","Expression","lastDoExpression","pop","statement","isPureish","isBinaryExpression","isParenthesizedExpression","isSequenceExpression","isUnaryExpression","isIdentifier","isAssignmentPattern"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { types as t, NodePath } from \"@babel/core\";\nimport {\n  wrapDoExpressionInIIFE,\n  collectControlFlowStatements,\n} from \"./utils.ts\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const { types: t } = api;\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? false;\n\n  return {\n    name: \"proposal-do-expressions\",\n    manipulateOptions: (_, parser) => parser.plugins.push(\"doExpressions\"),\n\n    visitor: {\n      DoExpression: {\n        exit(path) {\n          if (path.node.async) {\n            // Async do expressions are handled by proposal-async-do-expressions\n            return;\n          }\n          const controlFlowState = collectControlFlowStatements(path);\n          if (\n            controlFlowState.returnPath ||\n            controlFlowState.break.size ||\n            controlFlowState.continue.size\n          ) {\n            transformDoExpressionWithControlFlowStatements(path);\n          } else {\n            const body = path.node.body.body;\n            if (body.length) {\n              path.replaceExpressionWithStatements(body);\n            } else {\n              path.replaceWith(path.scope.buildUndefinedNode());\n            }\n          }\n        },\n      },\n    },\n  };\n\n  /**\n   * Transforms a do expression with control flow statements, e.g. break, continue, return.\n   * To support these statements, we memoize top level expressions in the do block and then\n   * unwrap the block.\n   * @param doExprPath NodePath<t.DoExpression>\n   * @returns\n   */\n  function transformDoExpressionWithControlFlowStatements(\n    doExprPath: NodePath<t.DoExpression>,\n  ) {\n    const doAncestors = new WeakSet<t.Node>();\n    let path: NodePath = doExprPath;\n    while (path) {\n      if (!path.node) return; // This node has been removed due to previous transformation\n      doAncestors.add(path.node);\n      if (path.isFunction()) {\n        let body = path.get(\"body\");\n        if (path.isArrowFunctionExpression()) {\n          // Do expression within parameters declarations OR expression body\n          if (body.isExpression() && doAncestors.has(body.node)) {\n            [body] = body.replaceWith(\n              t.blockStatement([t.returnStatement(body.node)]),\n            );\n            flattenStatement(body.get(\"body\")[0]);\n          }\n        }\n\n        // Do expression within function parameter lists\n        let foundDoExpression = false;\n        const deferredPatterns: t.PatternLike[] = [];\n        const deferredTemps: t.Identifier[] = [];\n        for (const param of path.get(\"params\")) {\n          const actualParam = param.isRestElement()\n            ? param.get(\"argument\")\n            : param.isTSParameterProperty()\n              ? param.get(\"parameter\")\n              : param;\n          foundDoExpression ||= doAncestors.has(actualParam.node);\n          if (foundDoExpression && !isLValSideEffectFree(actualParam)) {\n            const pattern = actualParam.node;\n            const uid = body.scope.generateUidIdentifier(\"do\");\n            actualParam.replaceWith(t.cloneNode(uid));\n            deferredPatterns.push(pattern);\n            deferredTemps.push(uid);\n          }\n        }\n        if (deferredPatterns.length) {\n          let blockBody: NodePath<t.BlockStatement>;\n          if (body.isBlockStatement()) {\n            blockBody = body;\n          } else {\n            [blockBody] = body.replaceWith(\n              t.blockStatement([t.returnStatement(body.node)]),\n            );\n          }\n\n          blockBody.unshiftContainer(\n            \"body\",\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(\n                t.arrayPattern(deferredPatterns),\n                t.arrayExpression(deferredTemps),\n              ),\n            ]),\n          );\n          flattenStatement(blockBody.get(\"body\")[0]);\n        }\n        return;\n      }\n      if (path.isStatement()) {\n        // Flatten the closest parent statement\n        flattenStatement(path);\n        return;\n      }\n      path = path.parentPath;\n    }\n    throw new Error(\n      \"Internal error: DoExpression must be in a statement. This is a Babel bug, please report it.\",\n    );\n\n    function flattenStatement(path: NodePath<t.Statement>) {\n      switch (path.type) {\n        case \"VariableDeclaration\": {\n          const statements: t.Statement[] = [];\n          for (const decl of path.get(\"declarations\")) {\n            const init = decl.get(\"init\");\n            const id = decl.get(\"id\");\n            if (doAncestors.has(init.node)) {\n              statements.push(...flattenExpression(init));\n            }\n            if (doAncestors.has(id.node)) {\n              statements.push(...flattenLVal(id, init.node, path.node.kind));\n            } else {\n              statements.push(\n                t.variableDeclaration(path.node.kind, [decl.node]),\n              );\n            }\n          }\n          path.replaceWithMultiple(statements);\n          break;\n        }\n        case \"ForStatement\": {\n          // Example:       for (var i = do { f1(); }; do { f2(); }; do { f3(); }) { ... }\n          // Transform to:  var temp1 = f1();\n          //                for (var i = temp1; ;) {\n          //                  var temp2 = f2();\n          //                  if (!temp2) break;\n          //                  ...\n          //                  f3();\n          //                }\n          const body: t.Statement[] = [];\n          const test = path.get(\"test\");\n          if (doAncestors.has(test.node)) {\n            body.push(\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n            );\n            test.remove();\n          }\n          body.push(path.node.body);\n          const update = path.get(\"update\");\n          if (doAncestors.has(update.node)) {\n            body.push(...flattenExpression(update, { discardResult: true }));\n            update.remove();\n          }\n          path.set(\"body\", t.blockStatement(body));\n\n          // Handle do expression within `init`\n          const init = path.get(\"init\");\n          if (doAncestors.has(init.node)) {\n            const initNode = init.isExpression()\n              ? t.expressionStatement(init.node)\n              : init.node;\n            init.remove();\n            const [newPath] = path.replaceWith(\n              t.blockStatement([initNode, path.node]),\n            );\n            flattenStatement(newPath.get(\"body\")[0]);\n          }\n          break;\n        }\n        case \"ForInStatement\":\n        case \"ForOfStatement\": {\n          // Example:       for (const i in do { f1(); }) { ... }\n          // Transform to:  var temp1 = f1();\n          //                for (var temp2 in temp1) {\n          //                  const i = temp2;\n          //                  ...\n          //                }\n\n          // Handle left side\n          const left = path.get(\"left\");\n          if (doAncestors.has(left.node)) {\n            const body = path.get(\"body\");\n            const uid = body.scope.generateDeclaredUidIdentifier(\"do\");\n            if (left.isVariableDeclaration()) {\n              const init = left.get(\"declarations\")[0].get(\"init\");\n              if (init.node) {\n                // Sloppy mode would allow:\n                // for (var x = do { ... } in <iterator>);\n                throw init.buildCodeFrameError(\n                  \"Complex variable declaration in for-in with do expression is not currently supported\",\n                );\n              }\n              init.replaceWith(t.cloneNode(uid));\n              const [newBody] = body.replaceWith(\n                t.blockStatement([left.node, body.node]),\n              );\n              flattenStatement(newBody.get(\"body\")[0]);\n            } else {\n              body.replaceWith(\n                t.blockStatement([\n                  ...flattenLVal(left, t.cloneNode(uid), null),\n                  body.node,\n                ]),\n              );\n            }\n            left.replaceWith(uid);\n          }\n\n          // Handle right side\n          const right = path.get(\"right\");\n          if (doAncestors.has(right.node)) {\n            path.replaceWithMultiple([...flattenExpression(right), path.node]);\n          }\n          break;\n        }\n        case \"WhileStatement\": {\n          // Example:      while (do { foo(); }) { ... }\n          // Transform to: while (true) { var temp = foo(); if (!temp) break; ... }\n          const test = path.get(\"test\");\n          path.set(\n            \"body\",\n            t.blockStatement([\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n              path.node.body,\n            ]),\n          );\n          test.replaceWith(t.booleanLiteral(true));\n          break;\n        }\n        case \"DoWhileStatement\": {\n          // Example:      do { ... } while (do { foo(); })\n          // Transform to: do { ...; var temp = foo(); if (!temp) break; } while (true)\n          const test = path.get(\"test\");\n          path.set(\n            \"body\",\n            t.blockStatement([\n              path.node.body,\n              ...flattenExpression(test),\n              t.ifStatement(\n                t.unaryExpression(\"!\", test.node),\n                t.breakStatement(),\n              ),\n            ]),\n          );\n          test.replaceWith(t.booleanLiteral(true));\n          break;\n        }\n        case \"ExpressionStatement\":\n          path.replaceWithMultiple(\n            flattenExpression(path.get(\"expression\"), { discardResult: true }),\n          );\n          break;\n        default:\n          path.insertBefore(flattenByTraverse(path));\n      }\n    }\n\n    function flattenExpression(\n      path: NodePath<t.Expression>,\n      opts: {\n        flattenTrailing?: boolean;\n        discardResult?: boolean;\n      } = {},\n    ): t.Statement[] {\n      if (isTopLevelCopyable(path)) {\n        return flattenByTraverse(path, opts.flattenTrailing);\n      }\n      const hasDoExpression = doAncestors.has(path.node);\n      if (hasDoExpression) {\n        if (path.isDoExpression()) {\n          const body = path.get(\"body\");\n          if (!opts.discardResult) {\n            const completions = body\n              .getCompletionRecords(/* shouldPreserveBreak */ true)\n              .filter(completion => completion.isExpressionStatement());\n            if (completions.length) {\n              const uid = body.scope.generateDeclaredUidIdentifier(\"do\");\n              for (const completion of completions) {\n                completion.replaceWith(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(uid),\n                    completion.node.expression,\n                  ),\n                );\n              }\n              path.replaceWith(uid);\n            } else {\n              path.replaceWith(path.scope.buildUndefinedNode());\n            }\n          }\n          return [body.node];\n        } else if (path.isAssignmentExpression()) {\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          if (doAncestors.has(left.node)) {\n            if (path.node.operator !== \"=\") {\n              throw path.buildCodeFrameError(\n                \"Do expression inside complex assignment expression is not currently supported.\",\n              );\n            }\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            path.replaceWith(uid);\n            return [\n              ...flattenExpression(right),\n              ...flattenLVal(left, right.node, null),\n            ];\n          }\n        } else if (path.isLogicalExpression()) {\n          const operator = path.node.operator;\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          const statements = [\n            ...flattenExpression(left),\n            t.ifStatement(\n              operator === \"&&\"\n                ? t.cloneNode(left.node)\n                : operator === \"||\"\n                  ? t.unaryExpression(\"!\", t.cloneNode(left.node))\n                  : t.binaryExpression(\n                      \"==\",\n                      t.cloneNode(left.node),\n                      t.nullLiteral(),\n                    ),\n              t.blockStatement(flattenExpression(right)),\n            ),\n          ];\n          path.replaceWith(\n            t.logicalExpression(path.node.operator, left.node, right.node),\n          );\n          return statements;\n        } else if (path.isConditionalExpression()) {\n          const test = path.get(\"test\");\n          const alternate = path.get(\"alternate\");\n          const consequent = path.get(\"consequent\");\n          const statements = [\n            ...flattenExpression(test),\n            t.ifStatement(\n              t.cloneNode(test.node),\n              t.blockStatement(flattenExpression(consequent)),\n              t.blockStatement(flattenExpression(alternate)),\n            ),\n          ];\n          path.replaceWith(\n            t.conditionalExpression(test.node, consequent.node, alternate.node),\n          );\n          return statements;\n        } else if (path.isOptionalMemberExpression() && path.node.computed) {\n          const object = path.get(\"object\");\n          const property = path.get(\"property\");\n          const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n          path.replaceWith(uid);\n          return [\n            ...flattenExpression(object),\n            t.ifStatement(\n              buildOptionalChainChecker(object.node),\n              t.blockStatement([\n                ...flattenExpression(property),\n                t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(uid),\n                    t.memberExpression(\n                      object.node,\n                      property.node,\n                      true /* computed */,\n                    ),\n                  ),\n                ),\n              ]),\n            ),\n          ];\n        } else if (path.isOptionalCallExpression()) {\n          const callee = path.get(\"callee\");\n          const calleeStatements = flattenExpression(callee);\n          const [newPath] = path.replaceWith(\n            t.callExpression(t.cloneNode(callee.node), path.node.arguments),\n          );\n          const callStatements = flattenCallExpression(\n            newPath,\n            opts.discardResult,\n          );\n          return [\n            ...calleeStatements,\n            t.ifStatement(\n              buildOptionalChainChecker(callee.node),\n              t.blockStatement(callStatements),\n            ),\n          ];\n        } else if (path.isCallExpression()) {\n          return flattenCallExpression(path, opts.discardResult);\n        }\n      }\n\n      if (hasDoExpression) {\n        return [\n          ...flattenByTraverse(path, opts.flattenTrailing),\n          intoTempVariable(path, opts.discardResult),\n        ];\n      } else {\n        return [intoTempVariable(path, opts.discardResult)];\n      }\n    }\n\n    function flattenCallExpression(\n      path: NodePath<t.CallExpression>,\n      discardResult?: boolean,\n    ): t.Statement[] {\n      const callee = path.get(\"callee\");\n      let thisArgument: NodePath<t.Expression | t.Super> | undefined;\n      const statements = [];\n      if (callee.isMemberExpression()) {\n        thisArgument = callee.get(\"object\");\n        if (!thisArgument.isSuper()) {\n          statements.push(...flattenExpression(thisArgument));\n        }\n      }\n      statements.push(...flattenExpression(callee as NodePath<t.Expression>));\n\n      for (const arg of path.get(\"arguments\")) {\n        if (arg.isSpreadElement()) {\n          const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n          statements.push(\n            ...flattenExpression(arg.get(\"argument\")),\n            t.expressionStatement(\n              t.assignmentExpression(\n                \"=\",\n                t.cloneNode(uid),\n                t.arrayExpression([arg.node]),\n              ),\n            ),\n          );\n          arg.replaceWith(t.spreadElement(uid));\n        } else {\n          statements.push(...flattenExpression(arg as NodePath<t.Expression>));\n        }\n      }\n\n      if (thisArgument) {\n        path.replaceWith(\n          t.callExpression(\n            t.memberExpression(\n              path.node.callee as t.Expression,\n              t.identifier(\"call\"),\n            ),\n            [\n              thisArgument.isSuper()\n                ? t.thisExpression()\n                : t.cloneNode(thisArgument.node),\n              ...(path.node.arguments as Array<t.Expression | t.SpreadElement>),\n            ],\n          ),\n        );\n        return [...statements, intoTempVariable(path, discardResult)];\n      } else {\n        path.replaceWith(t.callExpression(callee.node, path.node.arguments));\n      }\n      return [...statements, intoTempVariable(path, discardResult)];\n    }\n\n    function flattenLVal(\n      path: NodePath<t.LVal | t.PatternLike | t.OptionalMemberExpression>,\n      init: t.Expression | null | undefined,\n      declare: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\" | null,\n    ): t.Statement[] {\n      switch (path.type) {\n        case \"ObjectPattern\": {\n          wrapDoExpressionInIIFE(path);\n          // Fallthrough\n        }\n        case \"Identifier\": {\n          if (declare) {\n            return [\n              t.variableDeclaration(declare, [\n                t.variableDeclarator(path.node, init),\n              ]),\n            ];\n          } else {\n            return [\n              t.expressionStatement(\n                t.assignmentExpression(\"=\", path.node, init),\n              ),\n            ];\n          }\n        }\n        case \"MemberExpression\": {\n          return [\n            ...flattenByTraverse(path),\n            t.expressionStatement(t.assignmentExpression(\"=\", path.node, init)),\n          ];\n        }\n        case \"AssignmentPattern\": {\n          const left = path.get(\"left\");\n          const right = path.get(\"right\");\n          if (init) {\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            return [\n              t.expressionStatement(\n                t.assignmentExpression(\"=\", t.cloneNode(uid), init),\n              ),\n              t.ifStatement(\n                t.binaryExpression(\n                  \"===\",\n                  t.cloneNode(uid),\n                  t.buildUndefinedNode(),\n                ),\n                t.blockStatement([\n                  ...flattenExpression(right),\n                  t.expressionStatement(\n                    t.assignmentExpression(\"=\", t.cloneNode(uid), right.node),\n                  ),\n                ]),\n              ),\n              ...flattenLVal(left, uid, declare),\n            ];\n          } else {\n            return flattenLVal(path.get(\"left\"), right.node, declare);\n          }\n        }\n        case \"ArrayPattern\": {\n          const elements: t.ArrayPattern[\"elements\"] = [];\n          const statements: t.Statement[] = [];\n          for (const element of path.get(\"elements\")) {\n            if (!element.type || isLValSideEffectFree(element)) {\n              elements.push(element.node);\n              continue;\n            }\n            const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n            if (element.isRestElement()) {\n              elements.push(t.restElement(t.cloneNode(uid)));\n              statements.push(\n                ...flattenLVal(element.get(\"argument\"), uid, declare),\n              );\n            } else {\n              elements.push(t.cloneNode(uid));\n              statements.push(...flattenLVal(element, uid, declare));\n            }\n          }\n          return [\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", t.arrayPattern(elements), init),\n            ),\n            ...statements,\n          ];\n        }\n        default: {\n          throw path.buildCodeFrameError(\n            `Do expression inside ${path.type} is not currently supported`,\n          );\n        }\n      }\n    }\n\n    function flattenByTraverse(\n      path: NodePath,\n      flattenTrailing?: boolean,\n    ): t.Statement[] {\n      // Collect immediate descendant expressions\n      const expressions: NodePath<t.Expression>[] = [];\n      path.traverse({\n        Statement(path) {\n          path.skip();\n        },\n        Expression(path) {\n          expressions.push(path);\n          path.skip();\n        },\n      });\n\n      // Skip flattening trailing expressions that are after all the DoExpressions\n      let lastDoExpression: NodePath<t.Expression>;\n      if (!flattenTrailing) {\n        while (expressions.length) {\n          const path = expressions.pop();\n          if (doAncestors.has(path.node)) {\n            lastDoExpression = path;\n            break;\n          }\n        }\n      }\n\n      // Flatten the expressions\n      const statements: t.Statement[] = [];\n      for (const path of expressions) {\n        statements.push(...flattenExpression(path, { flattenTrailing: true }));\n      }\n      if (lastDoExpression) {\n        statements.push(...flattenExpression(lastDoExpression));\n      }\n      return statements;\n    }\n\n    function intoTempVariable(\n      path: NodePath<t.Expression>,\n      discardResult?: boolean,\n    ): t.Statement {\n      if (discardResult) {\n        return t.expressionStatement(path.node);\n      } else {\n        const uid = path.scope.generateDeclaredUidIdentifier(\"do\");\n        const statement = t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(uid), path.node),\n        );\n        path.replaceWith(uid);\n        return statement;\n      }\n    }\n  }\n\n  function buildOptionalChainChecker(node: t.Expression) {\n    if (noDocumentAll) {\n      return t.binaryExpression(\"!=\", t.cloneNode(node), t.nullLiteral());\n    } else {\n      return t.logicalExpression(\n        \"&&\",\n        t.binaryExpression(\"!==\", t.cloneNode(node), t.nullLiteral()),\n        t.binaryExpression(\"!==\", t.cloneNode(node), t.buildUndefinedNode()),\n      );\n    }\n  }\n});\n\nfunction isTopLevelCopyable(path: NodePath<t.Node>): boolean {\n  return (\n    path.isPureish() ||\n    path.isBinaryExpression() ||\n    path.isParenthesizedExpression() ||\n    path.isSequenceExpression() ||\n    (path.isUnaryExpression() &&\n      path.node.operator !== \"throw\" &&\n      path.node.operator !== \"delete\")\n  );\n}\n\nfunction isLValSideEffectFree(path: NodePath<t.Node>): boolean {\n  return (\n    path.isIdentifier() ||\n    (path.isAssignmentPattern() &&\n      isLValSideEffectFree(path.get(\"left\")) &&\n      path.get(\"right\").isPureish()) ||\n    (path.isRestElement() && isLValSideEffectFree(path.get(\"argument\")))\n  );\n}\n"],"mappings":"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","ignoreList":[]}